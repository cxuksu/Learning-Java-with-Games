/*
 * SumSprite.java - A class that performs the summation on two binary 
 * integers in 1's complement. It has to "carry around" the carry bit
 * generated by adding the two sign bits if the carry bit is 1.
 */
package sumonescomp;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;

/**
 *
 * @author cxu
 */
public class SumSprite extends AbsSprite {

    private int x, y;
    private int topMargin = 320, leftMargin = 100;
    private final int lineH = 20, gapH = 2, gapW = 5;
    private final int ARYLEN = 8;
    private int[] tempSum = new int[ARYLEN];
    private int[] carryBit = new int[ARYLEN];
    private int[] roundOver = new int[ARYLEN];
    private int[] roundCarryBit = new int[ARYLEN];
    private int[] finalSum = new int[ARYLEN];
    private int sumBit;
    private String onesCompOneStr, onesCompTwoStr;
    private int[] onesCompOneAry, onesCompTwoAry;
    private int countOne, countTwo, loop;
    private Font theF;
    private boolean oneDone, twoDone;
    private int loop2YFirstL;
    private PropertyChangeSupport sumDone;

    @SuppressWarnings("OverridableMethodCallInConstructor")
    public SumSprite() {
        initSprite();
    }

    @Override
    public void initSprite() {
        sumDone = new PropertyChangeSupport(this);
        countOne = 0;
        countTwo = 0;
        loop = 1;
        oneDone = false;
        twoDone = false;
        theF = new Font("Monospaced", Font.PLAIN, 18);
        for (int i = 0; i < ARYLEN; i++) {
            tempSum[i] = 0;
            carryBit[i] = 0;
            roundOver[i] = 0;
            roundCarryBit[i] = 0;
            finalSum[i] = 0;
        }
    }

    public void setCoor() {
        x = leftMargin;
        y = topMargin;
    }

    public void initSummationData(String onesOneStr, String onesTwoStr,
            int[] onesOneAry, int[] onesTwoAry) {
        this.onesCompOneStr = onesOneStr;
        this.onesCompTwoStr = onesTwoStr;
        this.onesCompOneAry = onesOneAry;
        this.onesCompTwoAry = onesTwoAry;
    }

    @Override
    public void updateSprite() {
        if (!(this.isActive())) {
            return;
        }
        if (oneDone == false) {
            updateAddition();
        } else if (roundOver[7] == 1) {
            updateRoundOver();
        } else if (roundOver[7] == 0) { // ignore updateRoundOver()
            twoDone = true;
        }
    }

    private void updateAddition() {
        countOne += 1;
        int i = onesCompOneAry.length - countOne;
        if (i > 0) {
            sumBit = onesCompOneAry[i] + onesCompTwoAry[i] + carryBit[i];
            switch (sumBit) {
                case 0:
                    tempSum[i] = 0;
                    carryBit[i - 1] = 0;
                    break;
                case 1:
                    tempSum[i] = 1;
                    carryBit[i - 1] = 0;
                    break;
                case 2:
                    tempSum[i] = 0;
                    carryBit[i - 1] = 1;
                    break;
                case 3:
                    tempSum[i] = 1;
                    carryBit[i - 1] = 1;
                    break;
            }
        } else { // i == 0, the sign bit
            sumBit = onesCompOneAry[0] + onesCompTwoAry[0] + carryBit[0];
            switch (sumBit) {
                case 0:
                    tempSum[0] = 0;
                    break;
                case 1:
                    tempSum[0] = 1;
                    break;
                case 2:
                    tempSum[0] = 0;
                    roundOver[7] = 1; // carry round
                    break;
                case 3:
                    tempSum[0] = 1;
                    roundOver[7] = 1; // carry round
                    break;
            }
            oneDone = true;
        }
    }

    public void updateRoundOver() {
        countTwo += 1;
        int i = finalSum.length - countTwo;
        if (i > 0) {
            sumBit = tempSum[i] + roundOver[i] + roundCarryBit[i];
            switch (sumBit) {
                case 0:
                    finalSum[i] = 0;
                    roundCarryBit[i - 1] = 0;
                    break;
                case 1:
                    finalSum[i] = 1;
                    roundCarryBit[i - 1] = 0;
                    break;
                case 2:
                    finalSum[i] = 0;
                    roundCarryBit[i - 1] = 1;
                    break;
                case 3:
                    finalSum[i] = 1;
                    roundCarryBit[i - 1] = 1;
                    break;
            }
        } else { // i == 0, the sign bit
            sumBit = tempSum[0] + roundOver[0] + roundCarryBit[0];
            switch (sumBit) {
                case 0:
                    finalSum[0] = 0;
                    break;
                case 1:
                    finalSum[0] = 1;
                    break;
                case 2:
                    finalSum[0] = 0;
                    break;
                case 3:
                    finalSum[0] = 1;
                    break;
            }
            twoDone = true;
        }
    }

    @Override
    public void paintSprite(Graphics2D g2d) {
        if (!(this.isVisible())) {
            return;
        }
        g2d.setFont(theF);
        paintAddition(g2d);
    }

    private void paintAddition(Graphics2D g2d) {
        if (loop == 1) {
            renderAddition(g2d, countOne);
            if (oneDone) {
                loop += 1;
            }
        } else if (loop == 2) {
            // after finishing the paint for the first summation, the
            // rendering needs to be kept on the screen and then move to 
            // paint the second summation.
            renderAddition(g2d, countOne);
            if (roundOver[7] == 1) {
                renderRoundCarry(g2d, countTwo);
            }
            if (twoDone) {
                this.setActive(false); // keep setVisible(true) for painting
                sumDone.firePropertyChange("sumDone", false, true);
            }
        }
    }

    private void renderAddition(Graphics2D g2d, int count) {
        setCoor();
        int localC = 1;

        FontMetrics fm = g2d.getFontMetrics();
        int strLen = fm.stringWidth(onesCompOneStr);
        int digitW = fm.stringWidth("F");
        y += lineH;
        int yFirstLine = y;
        g2d.drawString(onesCompOneStr, x, yFirstLine);
        y += lineH;
        g2d.drawString("+", x - 4 * gapW, y);
        g2d.drawString(onesCompTwoStr, x, y);
        y += 4 * gapH;
        g2d.drawLine(x - 5 * gapW, y, x + strLen + gapW, y);
        x += strLen - digitW;
        y += lineH + 2 * gapH;
        g2d.drawString("|", x, y);
        loop2YFirstL = y + lineH; // keep track of y for the loop2 
        // rendering the first summation dynamically
        while (localC < count) {
            int currBit = ARYLEN - localC;
            g2d.drawString("" + tempSum[currBit], x - 2 * localC * digitW, y);
            if ((currBit - 1 > 0) && (carryBit[currBit - 1] != 0)) {
                g2d.drawString("" + carryBit[currBit - 1],
                        x - 2 * localC * digitW - 2 * digitW, yFirstLine - lineH);
            }
            localC += 1;
        }
        if (oneDone) { // currBit == 0
            // plot the sign bit
            x = x - strLen + digitW;
            g2d.drawString("| " + tempSum[0] + " |", x, y);
            // plot the carry-in bitround carry bit with a rectangle
            x += 2 * digitW;
            y = yFirstLine - lineH;
            g2d.drawString("" + carryBit[0], x, y);
            // plot the carry over bit with a rectangle 
            if (roundOver[7] == 1) {
                x -= 2 * digitW;
                g2d.drawString("" + roundOver[7], x, y);
                g2d.drawRect(x, y - digitW - 2 * gapH, digitW, digitW + 4 * gapH);
            }
        }
    }

    private void renderRoundCarry(Graphics2D g2d, int count) {
        setCoor();
        int localC = 1;

        FontMetrics fm = g2d.getFontMetrics();
        int strLen = fm.stringWidth(onesCompOneStr);
        int digitW = fm.stringWidth("F");
        y = loop2YFirstL; // y continues
        g2d.drawString("+", x - 4 * gapW, y);
        g2d.drawString("" + roundOver[7], x + strLen - 3 * digitW, y);
        y += 4 * gapH;
        g2d.drawLine(x - 5 * gapW, y, x + strLen + gapW, y);
        x += strLen - digitW;
        y += lineH + 2 * gapH;
        g2d.drawString("|", x, y);
        // redering finalSum dynamically
        while (localC < count) {
            int currBit = ARYLEN - localC;
            g2d.drawString("" + finalSum[currBit], x - 2 * localC * digitW, y);
            localC += 1;
        }
        if (twoDone) { // currBit == 0
            // plot the last item
            g2d.drawString("| " + finalSum[0] + " |", x - strLen + digitW, y);
        }
    }

    // A method for debugging
    private void displayAry(int[] ary) {
        for (int i = 0; i < ary.length; i++) {
            System.out.print(ary[i]);
        }
        System.out.println();
    }

    public void addPropertyChangeListener(PropertyChangeListener pcl) {
        sumDone.addPropertyChangeListener(pcl);
    }
}
